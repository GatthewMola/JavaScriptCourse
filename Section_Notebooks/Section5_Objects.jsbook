{"cells":[{"kind":1,"language":"markdown","value":"    1. Basics\n\nRemember, objects are collections of key value pairs. If you have properties that highly related, you want to encapsulate them in an object.","index":0},{"kind":2,"language":"javascript","value":"let radius = 1;\nlet x = 1;\nlet y = 1;\n\n// Object-Oriented Programming (OOP)\nconst circle = {\n    radius: 1,\n    locations: {\n        x: 1,\n        y: 1\n    },\n    isVisible: true,\n    draw: function() { // When a function is nested within an object, it is referred to as a 'method' (sound familiar?)\n        console.log('draw\");')\n    }\n};\n\ncircle.draw(); // Method","index":1},{"kind":1,"language":"markdown","value":"    2. Factory Functions\n\nWhat happens when you want to call two circle objects? Creating duplicated of objects like this is messy; what happens if you have a bug in one object? Now you have bugs in all of the duplicates.","index":2},{"kind":2,"language":"javascript","value":"const circle = {\n    radius: 1,\n    locations: {\n        x: 1,\n        y: 1\n    },\n    isVisible: true,\n    draw: function() {\n        console.log('draw\");')\n    }\n};\n\nconst circle2 = {\n    radius: 1,\n    locations: {\n        x: 1,\n        y: 1\n    },\n    isVisible: true,\n    draw: function() {\n        console.log('draw\");')\n    }\n};","index":3},{"kind":1,"language":"markdown","value":"Instead of duplicating objects, we instead use Factory Functions to simulate duplicate objects.","index":4},{"kind":2,"language":"javascript","value":"const circle = {\n    radius: 1,\n    locations: {\n        x: 1,\n        y: 1\n    },\n    isVisible: true,\n    draw: function() {\n        console.log('draw\");')\n    }\n};\n\n// Factory Function\nfunction createCircel(radius, location) { // Just like self and object parameters\n    return {\n        radius: radius,\n        location: location,\n        isVisible: true,\n        draw: function() {\n            console.log('draw\");')\n        }\n    };\n}","index":5},{"kind":2,"language":"javascript","value":"// For now we're going to remove location and isVisible to make the function example easier to manage.\n\nfunction createCircle(radius) { // Just like self and object parameters\n    return {\n        radius, // Just like in python, we don't have to set the key equal to itself, it can standalone to be more efficient.\n        draw() { // When defining our method, just as in Python, we don't have to state that we are creating a function.\n            console.log('draw\");')\n        }\n    };\n}\n\nconst circle1 = createCircle(1);\nconsole.log(circle1);\n\nconst circle2 = createCircle(2);\nconsole.log(circle2);","index":6},{"kind":1,"language":"markdown","value":"    3. Constructor Functions\n\nOne main difference between Factory Functions and Constrcutor Functions is that Factories use Camel Notation (oneTwoThreeFour) and Constructors use Pascal Notation (OneTwoThreeFour) for their naming conventions.\n\nConstructor Functions also rely on the 'this' keyword. 'This' is equivalent to 'self' in Python, as it refers to the empty object being created, which will be recalled during dot notation.","index":7},{"kind":2,"language":"javascript","value":"function Circle(radius) {\n    this.radius = radius;\n    this.draw = function() {\n        console.log('draw');\n    }\n}\n\nconst circle = new Circle(1);","index":8},{"kind":1,"language":"markdown","value":"The 'new operator does 3 three things under the hood:\n- First, it create an empty object, such as (const x = {};)\n- Next, it takes the 'this' keys from the object mentioned in the statement and fills the empty object.\n- Finally, it will return that created object from the function created in the constructor function.","index":9},{"kind":1,"language":"markdown","value":"    Which function should I use?\n\nBoth types of functions are good for creating objects and functions. The constructor function is familiar to developers who have some experience programming in C# or Java. (Personally, I think I could get used to it easier as it is reminiscent of Python object orientation style).","index":10},{"kind":1,"language":"markdown","value":"    4. Dynamic Nature of Objects\n\nObjects can always be added to and removed from once they have been created.","index":11},{"kind":2,"language":"javascript","value":"const circle = {\n    radius = 1\n};\n\ncircle.color = 'yellow';\ncircle.draw = function() {}\n\ndelete circle.color;\ndelete circle.draw;\n\nconsole.log(circle);","index":12},{"kind":1,"language":"markdown","value":"We can delete circle.color and circle.draw from the constant circle variable because we are not reassigning the value of the object, we are only adjusting its properties.","index":13},{"kind":1,"language":"markdown","value":"    5. Constructor Property","index":14},{"kind":2,"language":"javascript","value":"function Circle(radius) {\n    this.radius = radius;\n    this.draw = function() {\n        console.log('draw');\n    }\n}\n\nconst another = new Circle(1);\n\nanother.constructor(); // The result will display the Circle function above in full.\n\ncircle.constructor(); // The result will display \"Object() { [native code] }\"\n// Why is this?","index":15},{"kind":2,"language":"javascript","value":"let x = {};\n// JavaScript will translate this declaration as \"let x = new Object();\"","index":16},{"kind":2,"language":"javascript","value":"// Other constructors in JavaScript and their associated literals:\n\nnew String(); // '', \"\", ``\nnew Boolean(); // true, false\nnew Number(); // 1, 2, 3, ...","index":17},{"kind":1,"language":"markdown","value":"    Takeaway:\n\nEvery object has a constructor property, and that references the function that was used to create that object.","index":18},{"kind":1,"language":"markdown","value":"    6. Functions are Objects","index":19},{"kind":2,"language":"javascript","value":"function Circle(radius) {\n    this.radius = radius;\n    this.draw = function() {\n        console.log('draw');\n    }\n}\n\nconst another = new Circle(1);","index":20},{"kind":2,"language":"javascript","value":"// Properties of the Circle Object\n\nCircle.name(); // \"Circle\"\nCircle.length(); // 1\nCircle.constructor(); // Function() { [native code] }\n// Becuase we created this object as a function, JavaScript will use the Funtion() constructor to put it together.","index":21},{"kind":2,"language":"javascript","value":"// For example, this is the Circle Object Function declared internally:\n\nconst Circle1 = new Function('radius', ` this.radius = radius;\nthis.draw = function() {\n    console.log('draw');\n}\n`);\n\n// Now that we are have created this object function, we can create new objects from it\n\nconst circle = new Circle1(1);\n// The result will display the new 'circle' object with the properties found in and created by the function.","index":22},{"kind":2,"language":"javascript","value":"// Now let's look at some internal methods at our disposal for this object function.\n\nCircle.call()\n// specfically, the line of code below\nCircle.call({}, 1)\n\n// The 'call' method is essentially the line of code below\nconst another = new Circle(1)\n\n// Just like in Python when calling other objects through methods, we have to declare values for each parameter in the object.\n// \"{}\" refers to an empty object which will hold the 'this' parameters\n// '1' refers to the value we are giving the \"radius\" parameter","index":23},{"kind":2,"language":"javascript","value":"// When we create a \"new\" Circle object, JavaScript creates an empty object and passes it through as the first argument of the\n// .call method\nCircle.call({}, 1);\nconst another = new Circle(1);","index":24},{"kind":1,"language":"markdown","value":"    Apply Method","index":25},{"kind":2,"language":"javascript","value":"Circle.apply();\n\n// The apply method will allow you to input an array as an argument.\n\nCircle.apply({}, [1, 2, 3]);","index":26},{"kind":1,"language":"markdown","value":"    7. Value vs. Reference Types\n\nIn JavaScript, we have to different categories of types:\n- Value/Primitives\n    - Number\n    - String\n    - Boolean\n    - Symbol (new)\n    - undefined\n    - null\n- Reference\n    - Objects\n    - Functions\n    - Arrays\n\nIt is very important to understand how primitives and Objects behave differently, especially before learning about prototypes.","index":27},{"kind":2,"language":"javascript","value":"let x = 10;\nlet y = x;\n\nx = 20;","index":28},{"kind":1,"language":"markdown","value":"Because these two variables are independent, when this code is executed, 'x' will equal 20, but 'y' will equal 10. When we created 'y', the current value of 'x' was *copied* over to 'y'. After 'y' was created, the value of 'x' no longer had any bearing over the value of 'y'.","index":29},{"kind":2,"language":"javascript","value":"let x = {value: 10};\nlet y = x;\n\nx.value = 20;","index":30},{"kind":1,"language":"markdown","value":"However, because we have now turned 'x' into an object, when we change the 'value' property of 'x', 'y's value has also changed. That is because the object is stored somewhere else in the memory, and the address of that memory location is stored inside that memory variable ('x' or 'y').\n\nIn this case, when we are declaring 'x' equal to 'y', we are copying the address or the reference of the variable, not the value. That is why the value for 'y' changes when the value for 'x' changes. Both 'x' and 'y' are pointing to te same object in memory.","index":31},{"kind":2,"language":"javascript","value":"let number = 10\n\nfunction increase(number) {\n    number++;\n}\n\nincrease(number);\nconsole.log(number);","index":32},{"kind":1,"language":"markdown","value":"If we run this code, the result will still be \"10\" despite our function. This is because the number parameter located in the function is completely independent to the number variable that is found outside of the function.\n\nHowever, if we change the 'number' variable to a reference type, we will get a different result.","index":33},{"kind":2,"language":"javascript","value":"let obj = {value: 10}\n\nfunction increase(obj) {\n    obj.value++;\n}\n\nincrease(obj);\nconsole.log(obj);\n// This code will display \"11\" rather than \"10\".","index":34},{"kind":1,"language":"markdown","value":"This is because we are dealing with an object - a reference type - which saves its value to the memory variable. So when the function alters this value, the memory variable's value is also effected.","index":35},{"kind":1,"language":"markdown","value":"    8. Enumerating Properties of an Object","index":36},{"kind":2,"language":"javascript","value":"const circle = {\n    radius = 1,\n    draw() {\n        console.log('draw');\n    }\n};\n\nfor (let key in circle) // Using the For/In loop, we can iterate over all of the properties of an object.\n    console.log(key, circle[key]); // We use the bracket notation here (circle of key) to display the value of this key or property.\n\nfor (let key of circle)\n    console.log(key);\n// When running this For/Of loop we will receive an error that states, \"circle is not iterable\".\n// This is because the circle object is not an array or a map (arrays and maps are iterable, objects are not).\n\n// However, we can run a method on this object to make it iterable.\nfor (let key of Object.keys(circle))\n    console.log(key);\n// The Object.keys() method will get all of the keys or properties of an object and will return them as an array.\n// 'Object.' is a built-in constructor function","index":37},{"kind":2,"language":"javascript","value":"// When we are creating an object in JavaScript...\nconst x = {value: 1};\n// We are calling the Object() constructor function:\nfunction Object() {}\n// When written out, the function looks like this:\nconst x = new Object();\n\n// Because all objects in JavaScript are functions, we have an assortment of built-in methods to use with them.\nObject.keys();\n// This method returns a string array which contains all the properties and methods of the selected object.\n\n// We also have the .entries method:\nObject.entries();\n// This returns each vale pair as an array. For example:\nfor (let entry of Object.entries(circle))\n    console.log(entry);\n// This will return each property of 'circle' and their paired value.\n// The first element of the array is the key or property, the second is the value.","index":38},{"kind":1,"language":"markdown","value":"Sometimes, you want to see if a given object has a given property or method. To do that, you can use the 'in' operator.","index":39},{"kind":2,"language":"javascript","value":"if ('radius' in circle) console.log('yes');\n// If the radius property is in the circle object, a yes message will display. If it is not, nothing will display.","index":40},{"kind":1,"language":"markdown","value":"    9. Cloning an Object","index":41},{"kind":2,"language":"javascript","value":"const circle = {\n    radius: 1,\n    draw() {\n        console.log('draw')\n    }\n};\n\nconst another = {};\n\nfor (let key in circle)\n    another[key] = circle[key];\n// This statement is equivalent to this code:\nanother['radius'] = circle['radius']\n// We are setting the 'radius' property of the 'circle' object equal to an empty property in the empty 'another' object.","index":42},{"kind":1,"language":"markdown","value":"This method, however, is a little bit old. In modern JavaScript we have better ways of achieving this endstate.","index":43},{"kind":2,"language":"javascript","value":"// Object.assign Method\nconst another = Object.assign({}, circle);\n// This is completely equivalent to this line of code:\nfor (let key in circle)\n    another[key] = circle[key];","index":44},{"kind":1,"language":"markdown","value":"The object described in the .assign method does not have to be empty. For example:","index":45},{"kind":2,"language":"javascript","value":"const another = Object.assign({\n    color: 'yellow'\n}, circle);\n// Adding this property within the .assign method will have be included in the rest of the circle object properties that will now\n// be assigned to the another object.","index":46},{"kind":1,"language":"markdown","value":"Another example of a more efficient way to clone an operator is the .spread method.","index":47},{"kind":2,"language":"javascript","value":"const another = {...circle};\n\n// This method is equivalent to writing out these methods:\nconst another = Object.assign({}, circle);\n// and\nfor (let key in circle)\n    another[key] = circle[key];","index":48},{"kind":1,"language":"markdown","value":"    10. Garbage Collection\n\nIn low level languages like C or C++, when creating an object, we need to allocate memory to it, and when we're done we need to deallocate memory. But in JavaScript, we don't have this concept. When the code for creating an object is run, memory is automatically allocated to it. When we are done using the object, we don't have to deallocate memory from it.\n\nThis is because JavaScript has what is called a __Garbage Collector__, whose job is to find variables and constants that are no longer used and then deallocate the memory from them.","index":49},{"kind":1,"language":"markdown","value":"    11. Math\n\nMath is another built-in object to JavaScript. It holds a number of constants and methods for arithmetic. If you're ever in the need for arithmetic operations, look them up online. Mozilla holds a giant library of all of them. The Mozilla site also offers helpful examples for how to use many of these methods.","index":50},{"kind":1,"language":"markdown","value":"    12. String\n\nAnother built-in object is the String object.\n","index":51},{"kind":2,"language":"javascript","value":"// String Primitive\nconst message = 'hi';\n\n// String Object\nconst another = new String('hi')\n// Because String('hi') is a constructor function, we need to employ the 'new' keyword when creating a new object.","index":52},{"kind":1,"language":"markdown","value":"However, when we use the dot notation on a primitive string variable, such as \"message\", the JavaScript engine internally wraps the variable with a string object. This happens under the hood.\n\nThere are many different methods for the String object. Some will come in handy for the exercises in this module so be sure to come back to this video later if you're stumped.","index":53},{"kind":1,"language":"markdown","value":"    Important Note for String Methods\n\nIf you use a method to alter a string variable/object, this will create a new string and not overwrite the original string.\n\nWhen using certain quotations within a string, you need to preface them with specific Escape Notation. Escape Notation can also do things like add new lines.","index":54},{"kind":1,"language":"markdown","value":"    13. Template Literals","index":55},{"kind":2,"language":"javascript","value":"// String Primitive\nconst message = 'This is my\\n first message';\n// This will display this message with a line break at 'my'\n// However, this code looks different then what we produce in the console.\n// If we want to make the code look the same as the display, we need to break up the string and concatenate the pieces.\nconst message = \n'This is my\\n' +\n'first message';","index":56},{"kind":1,"language":"markdown","value":"However, this approach is still messy and ugly code. This is where Template Literals come in.","index":57},{"kind":2,"language":"javascript","value":"//  JavaScript Literals\n// Object {}\n// Boolean true, false\n// String '', \"\"\n// Template ``\n\nconst another = \n`This is my \n'first' message`;","index":58},{"kind":1,"language":"markdown","value":"By using the Template Literals, we can write code that is formatted the same way we want to display it. Much more effective than Escape Notation.\n\nWe can also include placehoders in Template Literals:","index":59},{"kind":2,"language":"javascript","value":"let firstName = 'Matt'\n\nconst another = `Hello, it's me, ${firstName}`;\n// Just like in the Input functions in Python!","index":60},{"kind":1,"language":"markdown","value":"    14. Date\n\nThe Date Object and subsequent constructor function can display dates in many different formats.","index":61},{"kind":2,"language":"javascript","value":"const now = new Date();\nconst date1 = new Date('May 11 2018 09:00');\nconst date2 = new Date(2018, 4, 11, 9);\n// In this format, all arguments that don't have values are set to 0. January starts at 0, December is 11.\n\n// now.get__()\n// now.set__()\nnow.toDateString(); // To convert date values into strings\n// Will be important to me later as web apps will use this format to transfer date info between client and server.\nnow.toISOString();","index":62}]}