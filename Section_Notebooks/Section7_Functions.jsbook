{"cells":[{"kind":1,"language":"markdown","value":"    1. Function Declarations vs. Expressions","index":0},{"kind":2,"language":"javascript","value":"// Function Declaration\nfunction walk() {\n    console.log('walk');\n}\n\n// Anonymous Function Expression\nlet run = function() {\n    console.log('run');\n};\nlet move = run;\nrun();\nmove();","index":1},{"kind":1,"language":"markdown","value":"    2. Hoisting","index":2},{"kind":2,"language":"javascript","value":"// Function Declaration\nwalk();\n\nfunction walk() {\n    console.log('walk');\n}\n\n// Anonymous Function Expression\nlet run = function() {\n    console.log('run');\n};","index":3},{"kind":1,"language":"markdown","value":"A function can be called before it is defined in the code when using Function Declaration syntax. A function cannot be called before it is defined in the code when using Function Expression syntax. This is because when code is executed in JavaScript, the JS engine moves all of the function declarations to the top and runs them first. This concept is called \"hoisting\".","index":4},{"kind":1,"language":"markdown","value":"    3. Arguments","index":5},{"kind":2,"language":"javascript","value":"function sum(a, b) {\n    return a + b;\n}\nconsole.log(sum(1, 2)); // Returns '3'\n\nfunction sum(a, b) {\n    return a + b;\n}\nconsole.log(sum(1)); // Returns 'NaN' as you are returning \"1 + undefined\"\n\nfunction sum(a, b) {\n    return a + b;\n}\nconsole.log(sum(1, 2, 3, 4, 5)); // Returns '3' as only the first two arguments are used.","index":6},{"kind":2,"language":"javascript","value":"function sum(a, b) {\n    console.log(arguments);\n    return a + b;\n}\n\nconsole.log(sum(1, 2, 3, 4, 5));","index":7},{"kind":2,"language":"javascript","value":"function sum() {\n    let total = 0;\n    for (let value of arguments); // We are using a For/Of loop here despite not having an array because the 'arguments' object has an iterator.\n        total += value;\n    return total;\n}\n\nconsole.log(sum(1, 2, 3, 4, 5));","index":8},{"kind":1,"language":"markdown","value":"By changing our original function using the 'arguments' object, we have created one that can take any number of argument integers.","index":9},{"kind":1,"language":"markdown","value":"    4. The Rest Operator\n\nIn modern JavaScript, if you want to have a function with a varying number of parameters, you can use the rest operator (...). Hint: Don't confuse this with the spread operator from arrays.","index":10},{"kind":2,"language":"javascript","value":"function sum(...args) {\n    return args.reduce((a, b) => a + b);\n}\n\nconsole.log(sum(1, 2, 3, 4, 5, 10));\n// The rest operator will take all of these arguments and run them through the single parameter to create an array.","index":11},{"kind":1,"language":"markdown","value":"The code above is simply a more elegant way to run the For/Of loop function from the previous module. We are able to do this by using the rest operator.","index":12},{"kind":2,"language":"javascript","value":"function sum(discount, ...prices) {\n    const total = prices.reduce((a, b) => a + b);\n    return total * (1 - discount);\n}\n\nconsole.log(sum(0.1, 20, 30));","index":13},{"kind":2,"language":"javascript","value":"function sum(discount, ...prices, someValue) {\n    const total = prices.reduce((a, b) => a + b);\n    return total * (1 - discount);\n}\n\nconsole.log(sum(0.1, 20, 30, 1));\n// We will receive an error on this code because the rest parameter must be the last formal parameter.","index":14},{"kind":1,"language":"markdown","value":"The above error is why we call this the 'rest' operator. The operator will run the remaining arguments to call.","index":15},{"kind":1,"language":"markdown","value":"    5. Default Parameters","index":16},{"kind":2,"language":"javascript","value":"function interest(principal, rate, years) {\n    return principal * rate / 100 * years;\n}\n\nconsole.log(interest(10000, 3.5, 5));","index":17},{"kind":2,"language":"javascript","value":"function interest(principal, rate, years) {\n    rate = rate || 3.5; // By defining these truthy comparisons, we are defining default values for these parameters when no values are argued.\n    years = years || 5;\n    return principal * rate / 100 * years;\n}\n\nconsole.log(interest(10000));","index":18},{"kind":2,"language":"javascript","value":"// Similar syntax\nfunction interest(principal, rate = 3.5, years = 5) {\n    return principal * rate / 100 * years;\n}\n\nconsole.log(interest(10000));","index":19},{"kind":1,"language":"markdown","value":"    Note!:\n\nWhen using the syntax above, make sure that all parameters after the first default parameter are given values as well. For example, if we give 'rate' a default value but do not give one to 'years', it will confuse the JavaScript engine and produce NaN results when presenting arguments.","index":20},{"kind":1,"language":"markdown","value":"    6. Getters & Setters\n\nSpecial types of methods in objects.","index":21},{"kind":2,"language":"javascript","value":"const person = {\n    firstName: 'Matt',\n    lastName: 'Gola'\n}\n\nconsole.log(`${person.firstName} ${person.lastName}`);","index":22},{"kind":1,"language":"markdown","value":"However, we can rewrite this object to make it easier to call later on.","index":23},{"kind":2,"language":"javascript","value":"const person = {\n    firstName: 'Matt',\n    lastName: 'Gola',\n    // fullName: function() {}, // Below is cleaner syntax for this function code\n    fullName() {\n        return `${person.firstName} ${person.lastName}`\n    }\n}\n\nconsole.log(person.fullName());","index":24},{"kind":1,"language":"markdown","value":"However, we have a problem with this approach. because we defined this function within the 'person' object, it cannot be called outside of the 'person' object (outside of the person.() notation). This is where Getters & Setters come into play.","index":25},{"kind":2,"language":"javascript","value":"// getters => access properties\n// setters => change (mutate) them\n\n// Getter syntax\nconst person = {\n    firstName: 'Matt',\n    lastName: 'Gola',\n    get fullName() {\n        return `${person.firstName} ${person.lastName}`\n    }\n}\n\nconsole.log(person.fullName); // Now that we are using the getter syntax for our function, we no longer need to call the parameter like a function.","index":26},{"kind":2,"language":"javascript","value":"// Getter and Setter syntax together\nconst person = {\n    firstName: 'Matt',\n    lastName: 'Gola',\n    get fullName() {\n        return `${person.firstName} ${person.lastName}`\n    },\n    set fullName(value) {\n        const parts = value.split(' ');\n        this.firstName = parts[0];\n        this.lastname = parts[1];\n    }\n}\n\nperson.fullName = 'John Smith'; \n// Because of our inclusion of the setter function in our 'person' object, we can mutate the object from outside of it like we are here.\n\nconsole.log(person);","index":27},{"kind":1,"language":"markdown","value":"    7. Try & Catch","index":28},{"kind":2,"language":"javascript","value":"// What happens if we update our person.fullName declaration to a boolean?\nconst person = {\n    firstName: 'Matt',\n    lastName: 'Gola',\n    get fullName() {\n        return `${person.firstName} ${person.lastName}`\n    },\n    set fullName(value) {\n        const parts = value.split(' ');\n        this.firstName = parts[0];\n        this.lastname = parts[1];\n    }\n}\n\nperson.fullName = true; \n\nconsole.log(person);","index":29},{"kind":1,"language":"markdown","value":"This will result in an \"Uncaught\" TypeError because we cannot run the split method on a boolean (or anything else other than a string). In this case, we want to update our code for error handling.\n\nWe normally write code for error handling at the beginning of a function or method. This is called \"defensive programming\".","index":30},{"kind":2,"language":"javascript","value":"const person = {\n    firstName: 'Matt',\n    lastName: 'Gola',\n    get fullName() {\n        return `${person.firstName} ${person.lastName}`\n    },\n    set fullName(value) {\n        if (typeof value !== 'string') return;\n\n        const parts = value.split(' ');\n        this.firstName = parts[0];\n        this.lastname = parts[1];\n    }\n}\n\nperson.fullName = true; \n\nconsole.log(person);","index":31},{"kind":1,"language":"markdown","value":"Because we passed a conditional disregarding any declarations that are not a string, the 'person' object will instead return {firstName: \"Matt\", lastName: \"Gola\"} as those are the only two valid properties.","index":32},{"kind":1,"language":"markdown","value":"However, sometimes we want to report an error in our application. That's where we need to \"throw an exception\".","index":33},{"kind":2,"language":"javascript","value":"// Throwing exception example syntax\nconst person = {\n    firstName: 'Matt',\n    lastName: 'Gola',\n    get fullName() {\n        return `${person.firstName} ${person.lastName}`\n    },\n    set fullName(value) {\n        if (typeof value !== 'string') return;\n            throw new Error('Value is not a string.'); \n            // We are using the 'new' keyword here because we are creating a new object from a constructor function (Error()).\n\n        const parts = value.split(' ');\n        this.firstName = parts[0];\n        this.lastname = parts[1];\n    }\n}\n\nperson.fullName = true; \n\nconsole.log(person);","index":34},{"kind":1,"language":"markdown","value":"Now that we are stating how we would like to handle an exceptional error, we need to catch this error within a 'try' block.","index":35},{"kind":2,"language":"javascript","value":"// Try syntax\nconst person = {\n    firstName: 'Matt',\n    lastName: 'Gola',\n    get fullName() {\n        return `${person.firstName} ${person.lastName}`\n    },\n    set fullName(value) {\n        if (typeof value !== 'string') return;\n            throw new Error('Value is not a string.'); \n\n        const parts = value.split(' ');\n        this.firstName = parts[0];\n        this.lastname = parts[1];\n    }\n}\n\ntry {\nperson.fullName = true; \n}\ncatch (e) {\n    alert(e); // By running this catch condition after or try statement, we can display our thrown error message to the user.\n}\n\nconsole.log(person);","index":36},{"kind":1,"language":"markdown","value":"We can further can catch further erroneous results from our code by anticipating their outputs and writing in new conditions.","index":37},{"kind":2,"language":"javascript","value":"const person = {\n    firstName: 'Matt',\n    lastName: 'Gola',\n    get fullName() {\n        return `${person.firstName} ${person.lastName}`\n    },\n    set fullName(value) {\n        if (typeof value !== 'string') return;\n            throw new Error('Value is not a string.'); \n\n        const parts = value.split(' ');\n        if (parts.length !== 2)\n            throw new Error('Enter a first and last name.')\n\n        this.firstName = parts[0];\n        this.lastname = parts[1];\n    }\n}\n\ntry {\nperson.fullName = ''; \n}\ncatch (e) {\n    alert(e);\n}\n\nconsole.log(person);","index":38},{"kind":1,"language":"markdown","value":"Basically, when we throw an exception (i.e. we encounter an expected error), the lines after the throw statement are not executed. We will jump out of this method and the control will move to the catch block, which will describe what should happen given this exception.","index":39},{"kind":1,"language":"markdown","value":"    8. Local & Global Scope\n\nScope determines where a variable or constant is accessible.","index":40},{"kind":2,"language":"javascript","value":"// Globally Accessible\nconst message = 'hi'\n\n// Locally Accessible\n{\nconst message = 'hi';\n}\n\nconsole.log(message);","index":41},{"kind":1,"language":"markdown","value":"The same concept with code blocks is apparent within functions (and loops) themselves.","index":42},{"kind":2,"language":"javascript","value":"function start() {\n    const message = 'hi':\n\n    if (true) {\n        const another = 'bye';\n    }\n\n    console.log(another);\n}\n\nstart();\n// This will result in an error because 'another' in the console log is not defined. This is because 'another' is not defined within the scope\n// we are trying to call it from.","index":43},{"kind":1,"language":"markdown","value":"Global variables and constants can be called within all functions and loops. Local variables can only be called within the functions or loops they are defined in. Within functions and loops, local variables and constants take precedence over their global counterparts.\n\nBecause of their ability to be used by all functions and loops, it is best to avoid defining globally accessible variables and constants. Each function and loop in your code can accidently change their value and cause bugs and errors down the line.","index":44},{"kind":1,"language":"markdown","value":"    9. Let vs. Var\n\nYou will see 'var' used a lot online. This lecture will explain what it is, how it is different from let, and why it shouldn't be used most of the time.","index":45},{"kind":2,"language":"javascript","value":"function start() {\n    for (let i = 0 ; i < 5; i++) {\n        console.log(i);\n    }\n    console.log(i);\n}\n\nstart();","index":46},{"kind":1,"language":"markdown","value":"We will receive an error as a result because the variable 'i' was not defined within the scope of the statement its being called in.\n\nHowever, let's see what happens when we use 'var' instead of 'let'.","index":47},{"kind":2,"language":"javascript","value":"function start() {\n    for (var i = 0 ; i < 5; i++) {\n        console.log(i);\n    }\n    console.log(i);\n}\n\nstart();\n// Unlike 'let', which is limited to the code block in which it's defined, 'var' is limited to the *function* in which it's defined\n// Up until ES6 (ES2015), JavaScript only had the 'var' keyword to declare variables.\n// ES6 introduced the 'let' and 'const' keywords in order to declare more specific variables.","index":48},{"kind":1,"language":"markdown","value":"Instead of receiving an error, the console will display the values \"0, 1, 2, 3, 4, 5\". However, this is 6 values and we asked our for loop to only interate up to five index positions. We are receiving the value of \"5\" here because the loop terminate at '5', but the function then calls the current value of 'i' with the console.log command below the for loop. This is the issue with using the 'var' keyword to get around scope errors.","index":49},{"kind":2,"language":"javascript","value":"function start() {\n    for (var i = 0 ; i < 5; i++) {\n        if (true) {\n            var color = 'red';\n        }\n    }\n    console.log(color);\n}\n\nstart();\n// Instead of receiving an error, our result is 'red'.","index":50},{"kind":1,"language":"markdown","value":"The main issue with using 'var' is that it creates global variables. These variables are attached directly to the 'window' object, which is a central object related to JavaScript frontend programming. If you are using a third-party library of variables within your code, any variable located within this library bearing the same name as your 'var' variable no takes precedence over it. This is why it is best to avoid adding stuff to the window object.","index":51},{"kind":1,"language":"markdown","value":"    10. The 'This' Keyword\n\n'This' references the object that is executing the current function.","index":52},{"kind":2,"language":"javascript","value":"// If the function is part of an object, 'this' references the method.\n// method -> obj\n// If the function is not part of an object, 'this' references the global object on the window and in Node.\n// function -> global (window, global)\n\nconst video = {\n    title: 'a',\n    play() {\n        console.log(this);\n    }\n};\n\nvideo.play();","index":53},{"kind":1,"language":"markdown","value":"In this example, because 'play' is a method of the 'video' object, 'this' references 'video' itself. That is why the result will display as the \"title\" and \"play\" parameters in the console.","index":54},{"kind":2,"language":"javascript","value":"const video = {\n    title: 'a',\n    play() {\n        console.log(this);\n    }\n};\n\nvideo.stop = function() {\n    console.log(this);\n};\n\nvideo.stop();","index":55},{"kind":1,"language":"markdown","value":"Again, this will result in the console display the parameters for the 'video' object. This is because we are simply defining a new method for the 'video' object using different syntax.","index":56},{"kind":2,"language":"javascript","value":"const video = {\n    title: 'a',\n    play() {\n        console.log(this);\n    }\n};\n\nfunction playVideo() {\n    console.log(this);\n}\n\nplayVideo();","index":57},{"kind":1,"language":"markdown","value":"This function will result in the window object being displayed on the console, because we are declaring the function outside of a declared object.\n\nHowever, what if this is a constructor function? We call the constructor functions using the 'new' operator.","index":58},{"kind":2,"language":"javascript","value":"const video = {\n    title: 'a',\n    play() {\n        console.log(this);\n    }\n};\n\nfunction Video(title) {\n    this.title = title;\n    console.log(this);\n}\n\nconst v = new Video('a');","index":59},{"kind":1,"language":"markdown","value":"The result of this code will display the new 'Video' object on the console. This 'Video' object is completely separate from the 'video' object above. This is because when we use the 'new' operator, it creates an empty object, which the 'this' command within the constructor function then copies itself onto.","index":60},{"kind":2,"language":"javascript","value":"const video = {\n    title: 'a',\n    tags: ['a', 'b', 'c'],\n    showTags() {\n        this.tags.forEach(function(tag) {\n            console.log(tag);\n        });\n    }\n};\n\nvideo.showTags();","index":61},{"kind":1,"language":"markdown","value":"The code above will display the 3 items found in the 'tags' array parameter.\n\nHowever, what if you want to show the 'title' next to each 'tag'.","index":62},{"kind":2,"language":"javascript","value":"const video = {\n    title: 'a',\n    tags: ['a', 'b', 'c'],\n    showTags() {\n        this.tags.forEach(function(tag) {\n            console.log(this.title, tag);\n        });\n    }\n};\n\nvideo.showTags();","index":63},{"kind":1,"language":"markdown","value":"This code will result in 3 undefined elements because the 'this.title' parameter is not defined. That is because the 'this', in this case, is pointing to the window object. This is because our current code block is inside the callout function and not within the same scope of the 'video' object.","index":64},{"kind":2,"language":"javascript","value":"const video = {\n    title: 'a',\n    tags: ['a', 'b', 'c'],\n    showTags() {\n        this.tags.forEach(function(tag) {\n            console.log(this.title, tag);\n        }, this);\n    }\n};\n\nvideo.showTags();","index":65},{"kind":1,"language":"markdown","value":"To fix this issue, we are going to write include a 'this argument' within the callback function. This argument allows us to declare an object that callback function will reference. Notice that the 'this argument' is within the code block for showTags, meaning that it is within the scope of the 'video' object. Therefore, we only need to write 'this' for the engine to recognize which object we are referring to.\n\nHowever, not all methods in JavaScript give you the ability pass the 'this argument'. In these cases, we need to change 'this' within the scope we are working with.","index":66},{"kind":1,"language":"markdown","value":"    11. Changing 'This'","index":67},{"kind":2,"language":"javascript","value":"const video = {\n    title: 'a',\n    tags: ['a', 'b', 'c'],\n    showTags() {\n        const self = this;\n        this.tags.forEach(function(tag) {\n            console.log(this.title, tag);\n        });\n    }\n};\n\nvideo.showTags();\n// This is not the preferred approach, should not really be used.","index":68},{"kind":1,"language":"markdown","value":"Because we are declaring 'self' as 'this' within the showTags parameter of the 'video' object (and not within the callback function), it will refer to 'video' and not to window (global object).","index":69},{"kind":2,"language":"javascript","value":"// .call method approach\nfunction playVideo() {\n    console.log(this);\n};\n\nplayVideo.call({name: 'Matt'});\n\n//.apply method approach\nfunction playVideo() {\n    console.log(this);\n};\n\nplayVideo.apply({name: 'Matt'});","index":70},{"kind":1,"language":"markdown","value":"This difference between the call and apply methods is in their argument structure. The call methods accepts standalone additional arguments, the apply method only accepts additonal arguments within an array.","index":71},{"kind":2,"language":"javascript","value":"// .call method approach\nfunction playVideo() {\n    console.log(this);\n};\n\nplayVideo.call({name: 'Matt'}, 1, 2);\n\n//.apply method approach\nfunction playVideo() {\n    console.log(this);\n};\n\nplayVideo.apply({name: 'Matt'}, [1, 2]);","index":72},{"kind":1,"language":"markdown","value":"We also have the bind method approach. However, the bind method does not call back to our original function. Instead, it returns a new function sets 'this' to point to the new argument (object or primitive) permanently.","index":73},{"kind":2,"language":"javascript","value":"function playVideo() {\n    console.log(this);\n};\n\nconst fn = playVideo.bind({name: 'Matt'});\nfn();\n\n// We can also call the bind function immediately in the same line:\nplayVideo.bind({name: 'Matt'})();","index":74},{"kind":1,"language":"markdown","value":"Now, back to the original example.","index":75},{"kind":2,"language":"javascript","value":"const video = {\n    title: 'a',\n    tags: ['a', 'b', 'c'],\n    showTags() {\n        this.tags.forEach(function(tag) {\n            console.log(this.title, tag);\n        }.bind(this));\n    }\n};\n\nvideo.showTags();","index":76},{"kind":1,"language":"markdown","value":"By passing 'this' as the value for the .bind method (while within the scope of the showTags parameter), we can return the same affect as simply passing 'this' as the argument.","index":77},{"kind":1,"language":"markdown","value":"However, there is a newer and better solution than this: the __arrow function!__ The best thing about arrow functions is that they inherit the 'this' value.","index":78},{"kind":2,"language":"javascript","value":"const video = {\n    title: 'a',\n    tags: ['a', 'b', 'c'],\n    showTags() {\n        this.tags.forEach(tag => console.log(this.title, tag));\n    }\n};\n\nvideo.showTags();","index":79},{"kind":1,"language":"markdown","value":"Going forward, this is the modern approach to handling object callbacks.","index":80}]}